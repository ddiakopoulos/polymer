#version 450 core

layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

struct Vertex {
    vec4 position;
    vec4 scale_opacity;
    vec4 rotation;
    float sh[48];
};

struct VertexAttribute {
    vec4 conic_opacity;
    vec4 color_radii;
    uvec4 aabb;
    vec2 uv;
    float depth;
    uint pad;
};

layout (std430, binding = 0) readonly buffer Vertices {
    Vertex vertices[];
};

layout (std430, binding = 1) readonly buffer Cov3Ds {
    float cov3ds[];
};

layout (std140, binding = 2) uniform Params {
    vec4 camera_position;
    mat4 proj_mat;
    mat4 view_mat;
    uint width;
    uint height;
    float tan_fovx;
    float tan_fovy;
    uint sh_degree;
    uint num_gaussians;
};

layout (std430, binding = 3) writeonly buffer VertexAttributes {
    VertexAttribute attr[];
};

layout (std430, binding = 4) writeonly buffer NumTilesOverlap {
    uint tiles_overlap[];
};

const float SH_C0 = 0.28209479177387814;
const float SH_C1 = 0.4886025119029199;
const float SH_C2[5] = float[5](
    1.0925484305920792,
    -1.0925484305920792,
    0.31539156525252005,
    -1.0925484305920792,
    0.5462742152960396
);
const float SH_C3[7] = float[7](
    -0.5900435899266435,
    2.890611442640554,
    -0.4570457994644658,
    0.3731763325901154,
    -0.4570457994644658,
    1.445305721320277,
    -0.5900435899266435
);

mat3 get_projection_jacobian_approx(vec3 t) {
    float limx = 1.3 * tan_fovx;
    float limy = 1.3 * tan_fovy;
    float txtz = t.x / t.z;
    float tytz = t.y / t.z;
    t.x = min(limx, max(-limx, txtz)) * t.z;
    t.y = min(limy, max(-limy, tytz)) * t.z;

    float focal_x = float(width) / (2.0 * tan_fovx);
    float focal_y = float(height) / (2.0 * tan_fovy);

    return mat3(
        focal_x / t.z, 0.0, -(focal_x * t.x) / (t.z * t.z),
        0.0, focal_y / t.z, -(focal_y * t.y) / (t.z * t.z),
        0.0, 0.0, 0.0
    );
}

mat2 compute_cov2d(uint index, vec3 cam) {
    mat3 J = get_projection_jacobian_approx(cam);
    mat3 W = transpose(mat3(view_mat));
    mat3 Sigma = mat3(
        cov3ds[index * 6 + 0], cov3ds[index * 6 + 1], cov3ds[index * 6 + 2],
        cov3ds[index * 6 + 1], cov3ds[index * 6 + 3], cov3ds[index * 6 + 4],
        cov3ds[index * 6 + 2], cov3ds[index * 6 + 4], cov3ds[index * 6 + 5]
    );
    mat3 T = W * J;
    mat3 cov2d = transpose(T) * Sigma * T;

    // Add low-pass filter for anti-aliasing
    cov2d[0][0] += 0.3;
    cov2d[1][1] += 0.3;

    return mat2(cov2d);
}

vec3 get_sh_vec3(uint index, uint ind) {
    return vec3(
        vertices[index].sh[ind * 3 + 0],
        vertices[index].sh[ind * 3 + 1],
        vertices[index].sh[ind * 3 + 2]
    );
}

vec3 compute_sh(uint index) {
    vec3 ray_direction = vertices[index].position.xyz - camera_position.xyz;
    ray_direction = normalize(ray_direction);
    float x = ray_direction.x;
    float y = ray_direction.y;
    float z = ray_direction.z;

    vec3 c = SH_C0 * get_sh_vec3(index, 0);

    if (sh_degree >= 1) {
        c -= SH_C1 * get_sh_vec3(index, 1) * y;
        c += SH_C1 * get_sh_vec3(index, 2) * z;
        c -= SH_C1 * get_sh_vec3(index, 3) * x;
    }

    if (sh_degree >= 2) {
        c += SH_C2[0] * get_sh_vec3(index, 4) * x * y;
        c += SH_C2[1] * get_sh_vec3(index, 5) * y * z;
        c += SH_C2[2] * get_sh_vec3(index, 6) * (2.0 * z * z - x * x - y * y);
        c += SH_C2[3] * get_sh_vec3(index, 7) * z * x;
        c += SH_C2[4] * get_sh_vec3(index, 8) * (x * x - y * y);
    }

    if (sh_degree >= 3) {
        c += SH_C3[0] * get_sh_vec3(index, 9) * (3.0 * x * x - y * y) * y;
        c += SH_C3[1] * get_sh_vec3(index, 10) * x * y * z;
        c += SH_C3[2] * get_sh_vec3(index, 11) * (4.0 * z * z - x * x - y * y) * y;
        c += SH_C3[3] * get_sh_vec3(index, 12) * z * (2.0 * z * z - 3.0 * x * x - 3.0 * y * y);
        c += SH_C3[4] * get_sh_vec3(index, 13) * x * (4.0 * z * z - x * x - y * y);
        c += SH_C3[5] * get_sh_vec3(index, 14) * (x * x - y * y) * z;
        c += SH_C3[6] * get_sh_vec3(index, 15) * x * (x * x - 3.0 * y * y);
    }

    c += 0.5;
    c = max(c, vec3(0.0));

    return c;
}

float ndc2Pix(float v, int S) {
    return ((v + 1.0) * float(S) - 1.0) * 0.5;
}

void main() {
    uint index = gl_GlobalInvocationID.x;
    if (index >= num_gaussians) {
        return;
    }

    ivec2 tile_shape = ivec2(
        (width + 16 - 1) / 16,
        (height + 16 - 1) / 16
    );

    // Initialize as culled
    attr[index].color_radii.w = 0.0;
    tiles_overlap[index] = 0;

    // Transform to clip space
    vec4 p_hom = proj_mat * vertices[index].position;
    float p_w = 1.0 / (p_hom.w + 0.0001);
    vec3 ndc = p_hom.xyz * p_w;

    // Transform to view space
    vec4 p_view = view_mat * vertices[index].position;

    // Cull behind camera
    if (p_view.z <= 0.2) {
        return;
    }

    // Compute 2D covariance
    mat2 cov2d = compute_cov2d(index, p_view.xyz);
    float det = determinant(cov2d);
    if (det <= 0.0) {
        return;
    }

    // Compute conic (inverse of 2D covariance)
    mat2 conic = inverse(cov2d);
    attr[index].conic_opacity.xyz = vec3(conic[0][0], conic[0][1], conic[1][1]);
    attr[index].conic_opacity.w = vertices[index].scale_opacity.w;

    // Compute screen-space radius from eigenvalues
    float mid = 0.5 * (cov2d[0][0] + cov2d[1][1]);
    float lambda1 = mid + sqrt(max(0.1, mid * mid - det));
    float lambda2 = mid - sqrt(max(0.1, mid * mid - det));
    float lambda = max(lambda1, lambda2);
    float radii = ceil(3.0 * sqrt(lambda));

    // Screen-space position
    vec2 uv = vec2(ndc2Pix(ndc.x, int(width)), ndc2Pix(ndc.y, int(height)));

    // Compute tile bounding box
    uvec4 bounding_box = uvec4(
        uint(clamp(int((uv.x - radii) / 16.0), 0, tile_shape.x)),
        uint(clamp(int((uv.y - radii) / 16.0), 0, tile_shape.y)),
        uint(clamp(int((uv.x + radii + 16.0 - 1.0) / 16.0), 0, tile_shape.x)),
        uint(clamp(int((uv.y + radii + 16.0 - 1.0) / 16.0), 0, tile_shape.y))
    );

    uint num_tiles_overlap = (bounding_box.z - bounding_box.x) * (bounding_box.w - bounding_box.y);
    if (num_tiles_overlap == 0) {
        return;
    }

    attr[index].aabb = bounding_box;
    tiles_overlap[index] = num_tiles_overlap;
    attr[index].depth = p_view.z;
    attr[index].color_radii.w = radii;
    attr[index].color_radii.xyz = compute_sh(index);
    attr[index].uv = uv;
    attr[index].pad = 0;
}
